h2. Also see "BeepBeep demo/documentation site":http://beepbeep.dmitriid.com/

h2. BeepBeep a simple web application for Erlang

BeepBeep is a simple Web Application framework for Erlang inspired by Rails and Merb. It follows the 
principle of convention over configuration - meaning if you follow the code structure layout and a few
rules when building your app, it'll require no extra work on you behalf to map Url requests to your 
Controllers and Views.

BeepBeep is built on "MochiWeb":http://code.google.com/p/mochiweb/ and "ErlyDTL":http://code.google.com/p/erlydtl,
providing a super fast web server and the abiity to define your templates with the Django template language.

h3. Features
	
 * A script to generate a new web application (based on mochiweb's approach)
 * Session Server to store your application state
 * Before filter on your controllers for things like authentication 
 * Django templates for the view

h3. Getting Started

 # download the code
 # CD into the beepbeep directory
 # run make
 # generate a new web application by running  ./script/new_beep.erl YouAppName "DestinationDirectory

This will create a web app with everything you need. It includes a Sample controller (main_controller.erl).
To run the sample:

 # cd into the new application's directory you created above
 # Run make to compile the new project
 # Start the server: ./start-server.sh
 # Open a browser and visit "http://localhost:8000

h3. How it works:

You write a controller with a set of methods that look like this:
<pre>
<code>
handle_request(Action,Params)
</code>
</pre>

where Action is a string that will match to the request in the Url and
Params is an Array of optional parameters that will be passed to variables
in your controller.

BeepBeep will automatically map Url requests to controller and functions (or actions). For example a request to "/hello/show" would map to the "hello_controller" and invoke the "handle_request("show",[])" function. 

Here's an example:

<pre>
 <code>
%% hello_controller.erl
-module(hello_controller).

-export([handle_request/2, before_filter/0]).

%% Maps to http://localhost:8000/hello/show
handle_request("show",[]) ->
    {render, "hello/show.html",[{name,"BeepBeep"}]};

%% Maps to http://localhost:8000/hello/feed/2007
handle_request("feed",[Year]) ->
    %% Now Year contains the value 2007
    {render,"hello/feed.html",[{year,Year}]}.
  

%% Callback filter hook
before_filter(Params) ->
    ok.

 </code>
</pre>

From "handle_request" we return a tuple that tells the framework what view to use. Views
are located in the views directory. In our example we'll use the view located in the 
subdirectory "hello" and the file "show.html"

Here's an example of the "show.html" template:

<pre><code>
<h2>Hello from {{ name }} </h2>
</code></pre>

Which will result in:
<pre><code>
<h2>Hello from BeepBeep</h2>
</code></pre> 

The "name" key set in the controller is passed to the template and expanded using the Django format
via erlyDTL.

This approach provides a clean separation of the erlang logic in the controller and the html code in
the template.

You can also implement the before_filter to check requests before the matching "handle_request" is
called.  Filters that pass should simply return the atom ok, otherwise they should return one
of the request responses such as {render...} or {redirect..." 

More to come...
